<!DOCTYPE html>
<html>
<head>
<title>object-02</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>一.复习</h1>
<h3>面向对象</h3>
<ul>
<li>利用对象解决问题.</li>
<li>讲究的是凡事不用亲力亲为.</li>
<li>离不开面向过程,相当于是对面向过程的封装.</li>
<li>面向对象的好处:一般应用于大型软件的.开发,使用了面向对象的大型软件就像是使用了XMind进行组织一样.</li>
</ul>
<h3>工厂函数</h3>
<ul>
<li>就是对创建对象的过程进行了封装.</li>
<li>工厂函数的返回值是一个对象.</li>
<li>如果一个函数调用后,返回值是一个对象,那么就可以认为他是一个工厂函数</li>
</ul>
<h3>构造函数</h3>
<ul>
<li>如果一个函数用来配合new关键字创建对象,那就可以称为构造函数.</li>
</ul>
<h3>构造函数与普通函数的关系</h3>
<ul>
<li>构造函数与普通函数无异,本身就是一个东西</li>
</ul>
<h3>类</h3>
<ul>
<li>就是对一些具有相同特征与特性的对象的抽象描述.</li>
<li>在ES6之前,可以把构造函数看作是类.</li>
</ul>
<h3>实例</h3>
<ul>
<li>通过构造函数创建出来的对象</li>
<li><em>注:在口头描述上,实例指的是直系后代(在编程语言中,实力也指子孙后代)</em></li>
</ul>
<h3>实例类型</h3>
<ul>
<li>实例的类型就是构造函数的类型</li>
</ul>
<h3>原型&amp;原型的作用</h3>
<ul>
<li>原型就是js提供的一个实现继承的机制</li>
<li>原型就是为了让实例共享一些属性与方法,达到节省内存以及复用代码的目的</li>
</ul>
<h4>prototype</h4>
<ul>
<li>所有的函数默认含有prototype属性</li>
<li>作用:通过函数new出来的实例,都会继承prototype属性所<strong>指向</strong>的对象.</li>
<li>本质:</li>
</ul>
<h4><strong>proto</strong></h4>
<ul>
<li>所有的对象都含有<strong>proto</strong>属性</li>
<li>访问一个对象的属性时,如果对象自身没有,就会去<strong>proto</strong>指向的对象中查找</li>
</ul>
<h4>new构造函数自动执行的4个步骤</h4>
<ul>
<li>
<p>1.new关键字会创建一个新对象(就是在内存中开辟一个区域)</p>
</li>
<li>
<p>2.给新对象添加<strong>proto</strong>属性,该属性的值为<em>当前</em>构造函数prototype属性的值,新对象.<strong>proto</strong>=构造函数.prtotype</p>
</li>
<li>
<p>3.执行构造函数,执行时构造函数内的this指向新对象</p>
</li>
<li>
<p>4.返回新对象的地址</p>
</li>
</ul>
<h3>属性查找规则</h3>
<ul>
<li>先找自身,自身没有,顺着<strong>proto</strong>属性查找指定对象;</li>
<li>这个对象没有,继续顺着<strong>proto</strong>查找;</li>
<li>直到世界的尽头</li>
</ul>
<h1>二.新内容</h1>
<h2>继承的概念</h2>
<h3>方式介绍</h3>
<h4>1. 默认的原型继承</h4>
<ul>
<li><em>补充:动态修改原型</em></li>
</ul>
<h4>2.原型的覆写</h4>
<pre><code>    function Student(age) {
        this.age = age;
    }

    // 覆写构造函数的prototype属性值
    // 把Student.prototype修改为一个新的自定义对象
    Student.prototype = {
        run: function () {
            console.log('跑');
        }
    };

    // guoJing 继承 一个自定义的原型对象
    // 这个原型对象可以通过 Student.prototype 获取(但是这种方式不一定靠谱);
    // 也可以通过 guoJing.__proto__ 获取。
    var guoJing = new Student(38);
    guoJing.run();
</code></pre>

<h4>3．原型的注意事项</h4>
<ul>
<li>
<p>1.创建对象时,原型要先覆写,再去创建对象</p>
<pre><code>function Student(age) {
    this.age = age;
}
// 注意事项2：覆写时需要注重代码编写的顺序
var guoJing = new Student(38);

// 覆写构造函数的prototype属性值
// 把Student.prototype修改为一个新的自定义对象
Student.prototype = {
    constructor: Student,
    run: function () {
        console.log('跑');
    }
};

// 报错，因为在创建guoJing时，原型还没有被覆写，
// 所以guoJing继承的是默认的原型对象
guoJing.run();
</code></pre>

</li>
<li>
<p>2.原型覆写时尽量使用新对象</p>
<pre><code>var obj = {
count: function (a, b) {
   console.log(a + b);
    },
    con: function (a) {
        console.log(a);
    }
};
function Student(age) {
    this.age = age;
}

// 覆写构造函数的prototype属性值
// 把Student.prototype修改为一个新的自定义对象
Student.prototype = obj;
// 如果我想修改con方法，那么obj对象也会受到连带影响，
// 将来使用obj的时候，极有可能我已经忘记了这里对obj进行过修改，
// 就可能出现问题，为了防止自己给自己挖坑，还是不要使用已存在的对象为好。
Student.prototype.con = function (a) {
    return a;
};

var guoJing = new Student(38);
guoJing.run();
</code></pre>

</li>
<li>
<p>3.访问construcotr属性时，会不准确</p>
<pre><code>function Student(age) {
    this.age = age;
}

// 覆写构造函数的prototype属性值
// 把Student.prototype修改为一个新的自定义对象
Student.prototype = {
    // 因为我们自定义的原型对象，默认没有constructor属性，
    // 我们可以考虑自己补上，但是不补也无所谓，因为这个属性没太大卵用。
    constructor: Student,
    run: function () {
        console.log('跑');
    }
};

// guoJing 继承 一个自定义的原型对象
// 这个原型对象可以通过 Student.prototype 获取(但是这种方式不一定靠谱);
// 也可以通过 guoJing.__proto__ 获取。
var guoJing = new Student(38);
guoJing.run();

// 这种方式，访问construcotr属性时，会不准确。
console.log(guoJing.constructor);
</code></pre>

</li>
</ul>
<h2>js是对象与对象之间的继承</h2>
<h2>编程技巧(继承方式copy)</h2>
<pre><code>    //需求:让o2能够使用o对象里面的属性.
    //可以考虑直接把o对象的属性和值copy到o2身上完成需求


    var o={val:&quot;100&quot;};
    var o2={name:&quot;guo&quot;};
    //遍历o对象的属性和值
    //copy到o2身上
    for(var key in o){
        o2[key]=o[key];
    }

    console.log(o);
    console.log(o2);
</code></pre>

<h2>补充(内置的属性不可枚举)</h2>
<pre><code>    //可被遍历的,叫枚举
    //内置属性不可枚举:浏览器内置的属性,无法使用for in遍历出来
    var obj={val:100};

    obj.toString();
    obj.valueOf();

    //只能把我们自己添加的val属性遍历出来

    for(var key in obj){
        console.log(obj);
    }
</code></pre>

<h2>补充(extend)</h2>
<pre><code>    //该方法会把第二个对象的属性copy到第一个对象中
    function extend(o1,o2){
        for(var key in o2){
        o1[key]=o2[key];

        }
    }


    var obj1={val:23};
    var obj2={value:27};


    //extend可以实现多继承,本质上就是把多个对象的属性依次copy到原型对象中

    function Dog(age){

        this.age = age;

    }

    //分别把obj1和obj2的属性copy到原型对象中,这样实例就可以使用

    extend(Dog.prototype,obj1);
    extend(Dog.prototype,obj2);

    console.log(obj1);
    console.log(obj2);
</code></pre>

<h3>copy的优势</h3>
<ul>
<li>1.实现copy继承所需的函数名没有硬性要求</li>
<li>2.乱使用会造成内存资源浪费</li>
<li>3.通常都是配合原型来使用的</li>
</ul>
<h2>一个案例需求</h2>
<pre><code>    var obj={
        fn:function(){
            //谁调用fn,this指向谁
            console.log(this.name)
        }
    }

    //人类

    function Person(name,age){
        this.name = name;
        this.age = age;
    }

    //最好不要这么做
    //Person.prototype = obj;

    //可以考虑把obj对象里面的方法copy到Person的显示原型中,达到实例共享的目的

    for(var key in obj){
        Person.prototype[key]=obj.[key];
    }
    var huangRong = new Person('黄蓉', 18);
    var guoJing = new Person('郭靖', 38);
    huangRong.fn();
    guoJing.fn();
</code></pre>

<h2>Object.create(IE8以下不支持)函数上的方法</h2>
<ul>
<li>可以实现继承</li>
<li>1.Object是一个内置的构造函数</li>
<li>2.在Object自身上有很多方法,create是其中之一,可以实现继承</li>
</ul>
<h3>语法</h3>
<ul>
<li>Object.create(被继承的对象);</li>
<li>返回值:返回一个新对象,新对象继承传入到create方法的对象.</li>
<li>作用:就是创建一个新对象,并且指定新对象的继承的对象</li>
<li>局限性:应用场景有限</li>
</ul>
<h2>三个案例需求三种做法</h2>
<ul>
<li>1.extend</li>
<li>2.Object.create(copy)</li>
<li>3.Person.prototype=new Animal();<em>有限制场景:必须是两个构造函数</em></li>
</ul>
<h1>继承方式总结</h1>
<h2>什么是继承</h2>
<ul>
<li>一个对象可以使用另一个对象的东西</li>
<li>或者说 一个对象可以使用一个本不属于自己的东西</li>
<li>js中的原型就是对继承特性的实现.</li>
</ul>
<h2>继承方式1</h2>
<ul>
<li>
<p>默认原型继承(很常用)</p>
<pre><code>function Fn(){}
Fn.prototype.value=100;
var fn = new Fn();
</code></pre>

</li>
</ul>
<h2>继承方式2</h2>
<ul>
<li>
<p>覆写构造函数的显式原型</p>
<pre><code>function Fn(){

    value=100;

}

var fn = new Fn();
</code></pre>

</li>
</ul>
<h2>继承方式3</h2>
<ul>
<li>
<p>给显式原型混入属性</p>
<pre><code>function extend(o1, o2) {

    for ( var key in o2 ) {

        o1[key] = o2[key];

    }  

}

var obj = { add: function (a,b) {

                    console.log(a+b) 

                } 

        } 

function Fn() {}

extend(Fn.prototype, obj);

extend(Fn.prototype, {
    value: 100
});

var fn = new Fn();
</code></pre>

</li>
</ul>
<h2>继承方式4</h2>
<ul>
<li>
<p>Object.create</p>
<pre><code>var obj = { value: 100 }
var newObj = Object.create(obj);
</code></pre>

</li>
</ul>
<h2>继承方式5</h2>
<ul>
<li>
<p>借用Object.create方法覆写显式原型</p>
<pre><code>var obj = { value: 100 }
function Fn() {}
Fn.prototype = Object.create(obj);
var fn = new Fn();
</code></pre>

</li>
</ul>
<h2>继承方式6</h2>
<ul>
<li>
<p>复合式原型继承</p>
<pre><code>function PrFn() {}
PrFn.prototype.value = 100;
function Fn() {}
Fn.prototype = new PrFn()
var fn = new Fn();
</code></pre>

</li>
</ul>
<h4>再次穿插一个编程技巧</h4>
<ul>
<li>借用某某函数给我的实例添加属性</li>
</ul>
<h2>延伸补充 - 模拟实现Object.create</h2>
<pre><code>    function create(obj){
        function F(){}
        F.prototype=obj;
        return new F();
    }

    var obj={value:1}
    //创建一个新对象,指定新对象继承obj
    var newObj=create(obj);

    console.log(newObj.value);
</code></pre>

<h1>三.开启新篇章</h1>
<h2>1. 对象的原型对象一定是有终点的</h2>
<h3>1.函数默认的原型对象继承结构</h3>
<pre><code>    function Person(){

        this.name=name;

    }

    console.log(Person.prototype);

    //默认原生对象的属性:constructor

    //发现Person.prototype这个对象继承的对象中constructor属性值为Object构造函数
    //那么可以猜想Person.prototype继承的对象会不会是Object.prototype

    console.log(Person.prototype.__proto__.constructor);

    //验证猜想
    console.log(Person.prototype.__proto__===Object.prototype);
</code></pre>

<hr />
<ul>
<li>Person.prototype继承Object.prototype</li>
<li>Object.prototype是终点</li>
</ul>
<h2>2.静态成员与实例成员</h2>
<ul>
<li>添加给实力的属性或者方法,就叫做实例成员.</li>
<li>
<p>添加给类自己的属性或者方法,就叫做类成员(静态成员).</p>
<pre><code>//这是构造函数也是类
function Person(){
    //这里的name,age属性,因为将来要添加到实例身上,所以称之为实例成员(实例属性)
    this.name=name;
    this.age = age;

}

//直接添加到类上的属性和方法,叫做静态成员,或者类成员

Person.maxAge=200;
</code></pre>

</li>
<li>1.实例不可以直接访问静态成员</li>
<li>2.构造函数(类)不可以直接访问实例成员</li>
</ul>
<h4>实例能够访问实例成员,类能够访问类成员</h4>
<ul>
<li>
<p>类成员(静态成员)只能由构造函数自己访问</p>
</li>
<li>
<p>构造函数内添加实例成员,也只有实例能够访问</p>
</li>
</ul>
<hr />
<ul>
<li>原型对象里面的成员,原型自己也可以访问</li>
<li>原型对象里面的成员,构造函数(类)不可以访问</li>
<li>原型对象里面的成员,实例可以访问</li>
</ul>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
