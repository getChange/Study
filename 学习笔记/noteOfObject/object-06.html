<!DOCTYPE html>
<html>
<head>
<title>object-06</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>第六天学习</h1>
<h1>typeof</h1>
<ul>
<li>运算结果只有拥有以下几种:object string number boolean function undefined</li>
</ul>
<h1>setTimeout</h1>
<ul>
<li>setTimeout是全局下的一个函数</li>
<li>第一个参数要求是回调函数</li>
<li>
<p>传入setTimeout的回调函数是异步执行的(异步即:不是随着代码的顺序执行)(setTimeout自己是马上执行的)</p>
<pre><code>function callback(){
    console.log(111);
}

setTimeout(callback,0);//后执行(异步执行)
console.log(222);//先执行
</code></pre>

</li>
</ul>
<h1>面试题(setTimeout)</h1>
<pre><code>     var arr = ['第一句话','第二句话','第三句话','第四句话'];
     for ( let i = 0, len = arr.length; i &lt; len; i++ ) {

       //因为传入定时器的回调,在循环结束之后才执行,所以打印的值为4
       setTimeout(function () {
           console.log(arr[i]);
       }, 1000 * (i + 1));

    }

   /*----------------------------------*/
</code></pre>

<h2>自调函数的作用</h2>
<ul>
<li>
<p>全局变量污染:过多的全局变量,极易出现冲突与混淆</p>
</li>
<li>
<p>沙箱模式(命名空间):防止全局变量污染</p>
<pre><code>(function () {
    var a = 1
})
</code></pre>

</li>
<li>
<p>自调函数传参</p>
<pre><code>var b =10;
var c=10;
(function(w){

    var a=1;

    var location = w.location;

    var setTimeout = w.setTimeout;

    setTimeout(function(){

        console.log(a);

    },1000);

})(window);


(function(global){

    console.log(global.location.href)

})(window);
</code></pre>

</li>
</ul>
<blockquote>
<p>自调传入window一般有两个作用</p>
<ol>
<li>
<p>提升全局变量的查找时间</p>
</li>
<li>
<p>有助于代码的压缩   
</p>
</li>
</ol>
</blockquote>
<h2>函数四种调用模式</h2>
<h3>函数调用模式 ==&gt; 函数名()</h3>
<ul>
<li>
<p>内部this指向全局对象(window)</p>
<pre><code>function fn() {

    console.log(this)

}

fn();//函数名调用,this指向window

/*------------------------------------*/

var obj = {

    inFn: function () {

        console.log(this)

    }

};

var outFn = obj.inFn;

outFn();//函数名调用,this指向window     
</code></pre>

</li>
</ul>
<h3>　方法调用模式 ==&gt; 对象.函数名() || 对象<a href="">函数名</a></h3>
<ul>
<li>
<p>内部的this指向方法所属的对象</p>
<pre><code>    var obj = {

    fn: function () {

        console.log(this)

    }

};

obj.fn();

/*------------------------------------*/

function fn() {

    console.log(this)

}

var o={};

o.f=fn;
o.f();//方法调用模式,this指向o

/*------------------------------------*/

var objec={
    obje:{
        fn: function () {

            console.log(this)

        }
    }
}

objec.obje.fn();//方法调用模式,this指向fn所属的obje对象

/*-------------------------------------*/

var ob={
    111: function () {
        console.log(this);
    }
};
ob[111]();//方法调用模式,this指向111所属的ob对象
</code></pre>

</li>
</ul>
<h3>　构造器调用模式 ==&gt; new 函数名() || new.函数名() || new<a href="">函数名</a></h3>
<ul>
<li>
<p>内部的this指向新创建的实例</p>
<pre><code>function Person(age) {
    this.age = age;
    console.log(this);
    console.log(this instanceof Person);
}

new Person(16);//这是构造器模式,内部的this指向新创建的实例

/*------------------------------------------*/

var obj={
    fn: function () {
        console.log(this)
        console.log(this instanceof obj.fn)
    }
};

new obj.fn();//这是构造器模式,内部的this指向新创建的实例
</code></pre>

</li>
</ul>
<h3>上下文调用模式(间接调用模式) ==&gt; 函数名.call() || 对象.函数名.call() || new 对象[函数名].call()</h3>
<h3>上下文调用模式(间接调用模式) ==&gt; 函数名.apply() || 对象.函数名.apply() || new 对象[函数名].apply()</h3>
<ul>
<li>call和apply是来自Function.prototype里面的两个方法;</li>
<li>这两个方法有一个共同点,就是可以指定函数执行时内部函数的this指向</li>
<li>
<p>内部的this指向自定义的对象，如果传入空，this指向全局对象window。</p>
</li>
<li>
<p>语法:函数名.call(指定函数执行时的this指向);</p>
</li>
<li>
<p>语法:函数名.apply(指定函数执行时的this指向);</p>
<pre><code>function fn(){
    console.log(this);
}

//通过fn调用call方法,call方法内部会反过来调用fn,
//并且指定fn执行时内部的this为数组
fn.call([1,2,3,4,5])

/*-----------------------------------*/

var obj={
    fn: function () {
        console.log(this);
    }
}

obj.fn.call(val:1);
</code></pre>

</li>
<li>
<p>call与apply的补充</p>
<pre><code>function fn(){

    console.log(this);

}

fn.call({val:1}); // 内部的this指向字面量对象

fn.call(1);  // 内部的this指向1的包装对象

fn.apply('a'); // 内部的this指向'a'的包装对象

fn.apply(null); // 内部的this指向window

fn.call(undefined); // 内部的this指向window

fn.call(); // 内部的this指向window
</code></pre>

</li>
</ul>
<h4>toString</h4>
<ul>
<li>
<p>Object.prototype.toString:执行时根据内部的this,返回一个这样的字符串'[object this的类型]'</p>
<pre><code>Object.prototype.toString();//[object Object]
Object.prototype.toString.call([1,2]);//因为[1,2]是Array类型的对象,返回的是[object Array]
Object.prototype.toString.call(Array);//因为Array是Function类型的对象,返回的是[object Function]
</code></pre>

</li>
<li>
<p>这个方法一般用来判断ECMAScript内置的十大对象类型(9大构造函数的实例+Math)</p>
</li>
<li>
<p>内置的9大构造函数,他们的prototype显示原型对象中,都定义了自己的toString方法,所以他们的实例,会优先使用自己的toString</p>
<pre><code>console.log(Object.prototype.toString.call({}));  // [object Object]

console.log(Object.prototype.toString.call([])); // [object Array]

console.log(Object.prototype.toString.call(/a/));  // [object RegExp]

console.log(Object.prototype.toString.call(function(){}));  // [object Function]

console.log(Object.prototype.toString.call(new Date));  // [object Date]

console.log(Object.prototype.toString.call(new String)); // [object String]

console.log(Object.prototype.toString.call(new Number)); // [object Number]

console.log(Object.prototype.toString.call(new Boolean)); // [object Boolean]

console.log(Object.prototype.toString.call(new Error)); // [object Error]

console.log(Object.prototype.toString.call(Math)); // [object Math]

console.log(Object.prototype.toString.call(null)); // [object Null]

console.log(Object.prototype.toString.call(undefined));  // [object Undefined]
</code></pre>

</li>
</ul>
<h3>call和apply的具体语法</h3>
<ul>
<li>call</li>
</ul>
<blockquote>
<p>语法: 函数名.call(自定义的this指向,实参1,实参2,实参3,实参4...)
注意:第一个参数只是为了指定函数执行时his的指向,并不会作为参数传入进去</p>
</blockquote>
<pre><code>     function add(a, b)  {
        console.log(a + b);
    }
    add.call(300, 10, 20);  // 结果为30
</code></pre>

<ul>
<li>apply</li>
</ul>
<blockquote>
<p>语法: 函数名.apply(自定义的this指向,[实参1,实参2,实参3,实参4...])
注意:第一个参数只是为了指定函数执行时his的指向,并不会作为参数传入进去;第二个参数要求是数组或者伪数组,apply会自动把数组中的内容平铺传入到函数中</p>
</blockquote>
<pre><code>     function add(a, b)  {
        console.log(a + b);
    }
    add.apply(300, [50, 50]);  // 结果100
    add.apply(300, { 0:20, 1:20, length:2 });  // 结果40
</code></pre>

<h5>使用技巧</h5>
<ul>
<li>方法借用</li>
</ul>
<blockquote>
<p>1.借用数组的push方法,给obj对象按照下标添加属性</p>
</blockquote>
<pre><code>    var obj = {};

    [].push.call(obj,10);//this指向obj
</code></pre>

<blockquote>
<p>2.借用数组的pop方法,删除伪数组o对象的最后一个下标属性值</p>
</blockquote>
<pre><code>    var o={
        0:10,
        1:20,
        2:30,
        length:3
    }

    [].pop.call(o);
</code></pre>

<blockquote>
<p>3.构造函数借用</p>
</blockquote>
<pre><code>    function Person(name, age) {
        this.name = name;
        this.age = age;
    }

    function Student(name, age) {
        // 想给Student的实例也添加name和age属性

        // Student执行时，this指向小红(即小红就是this，this就是小红)，
        // 那么我想要Person执行时，它里面的this指向小红，
        // 我就可以通过call指定Person里面的this为小红，
        // 因为小红就是this，所以给call传this。
        Person.call( this, name, age );
    }

    var xiaohong = new Student('小红', 16);
    console.log(xiaohong);
</code></pre>

<blockquote>
<p>4.通过伪数组获取真数组</p>
</blockquote>
<pre><code>    // 如果把一个伪数组转换为真数组

    var obj = {

        0: 100,

        1: 200,

        length: 2

    };

    // slice可以通过一个旧数组，截取获取一个新数组

    console.log([1, 2, 3].slice(0, 1));

    console.log([1, 2, 3].slice());

    console.log([].slice.call(obj));

    /*---------------------------------------*/

    // 获取最大值

    function getMax() {

        // 借用apply平铺arguments，给max方法传参

        console.log(Math.max.apply(null, arguments));

    }

    getMax(1,2,4,20);
</code></pre>

<h2>函数的四种调用模式</h2>
<ul>
<li>函数中的this,是动态变化的,不同的调用方式,this志向不同,说明函数中的this与调用有关，和定义无关。</li>
</ul>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
