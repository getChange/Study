## 1.使用`typeof === "object"`判断`bar`是不是一个对象有什么潜在的弊端?如何避免弊端?
- 使用`typeof`的弊端和使用`instanceof`是一样的
```javascript
let obj = {};
let arr = [];

console.log(typeof obj === 'object'); //true
console.log(typeof arr === 'object'); //true
console.log(typeof null === 'object'); //true
```
- 通过`Object.prototype.toString.call(bar) === "[object Object]"`来避免
```javascript
let obj = {};
let arr = [];

console.log(Object.prototype.toString.call(obj)); //[object Object]
console.log(Object.prototype.toString.call(arr)); //[object Array]
console.log(Object.prototype.toString.call(null)); //[object null]
```
- `[] === false`是返回`false`
## 2.下面的代码会在console输出什么?为什么?
```javascript
(function () {
    var a = b = 3;
})();

console.log("a defined?" + (typeof a !== 'undefined'));
console.log("b defined?" + (typeof b !== 'undefined'));
```
- 与变量作用域有关
```javascript
console.log(b);//3
console.log(typeof a);//undefined
//拆解一下自执行函数变量赋值
// b = 3;
// var a = b;
``` 
- `b`是全局变量,`a`是自执行函数中的一个局部变量
## 3.下面的代码会在console输出什么?为什么?
```javascript
var myObject = {
        foo:"bar",
        func: function () {
            var self = this;
            console.log("outer func: this.foo = " + this.foo);//bar
            console.log("outer func: self.foo = " + self.foo);//bar
            (function() {
                console.log("inner func:  this.foo = " + this.foo);//undefined
                console.log("inner func:  self.foo = " + self.foo);//bar
            }());
            //解决方法:闭包
            (function(t) {
                console.log("inner func:  this.foo = " + t.foo);//bar
                console.log("inner func:  self.foo = " + self.foo);//bar
            }(self));
        }
    }
    myObject.func();
```
- 重点第三个`this`:在`ES6`之前，`JavaScript`只有函数作用域，所以`func`中的`IIFE`有自己的独立作用域，并且它能访问到外部作用域中的`self`，所以第三个输出会报错，因为`this`在可访问到的作用域内是`undefined`