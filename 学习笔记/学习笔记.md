### js原生实现双向数据绑定
- 第一种方式
- js
```javascript
function DataBinder( object_id ) {
    // Create a simple PubSub object
    var pubSub = {
                callbacks: {},
                on: function( msg, callback ) {
                    this.callbacks[ msg ] = this.callbacks[ msg ] || [];
                    this.callbacks[ msg ].push( callback );
                },
                publish: function( msg ) {
                    this.callbacks[ msg ] = this.callbacks[ msg ] || [];
                    for ( var i = 0, len = this.callbacks[ msg ].length; i < len; i++ ) {
                        this.callbacks[ msg ][ i ].apply( this, arguments );
                    }
                }
            },
            data_attr = "data-bind-" + object_id,
            message = object_id + ":input",
            timeIn;
            changeHandler = function( evt ) {
                var target = evt.target || evt.srcElement, // IE8 compatibility
                        prop_name = target.getAttribute( data_attr );
                if ( prop_name && prop_name !== "" ) {
                    clearTimeout(timeIn);
                    timeIn = setTimeout(function(){
                        pubSub.publish( message, prop_name, target.value );
                    },50);

                }
            };
    // Listen to change events and proxy to PubSub
    if ( document.addEventListener ) {
        document.addEventListener( "input", changeHandler, false );
    } else {
        // IE8 uses attachEvent instead of addEventListener
        document.attachEvent( "oninput", changeHandler );
    }
    // PubSub propagates changes to all bound elements
    pubSub.on( message, function( evt, prop_name, new_val ) {
        var elements = document.querySelectorAll("[" + data_attr + "=" + prop_name + "]"),tag_name;
        for ( var i = 0, len = elements.length; i < len; i++ ) {
            tag_name = elements[ i ].tagName.toLowerCase();

            if ( tag_name === "input" || tag_name === "textarea" || tag_name === "select" ) {
                elements[ i ].value = new_val;
            } else {
                elements[ i ].innerHTML = new_val;
            }
        }
    });
    return pubSub;
}
function DBind( uid ) {
    var binder = new DataBinder( uid ),
    user = {
        // ...
        attributes: {},
        set: function( attr_name, val ) {
            this.attributes[ attr_name ] = val;
            // Use the `publish` method
            binder.publish( uid + ":input", attr_name, val, this );
        },
        get: function( attr_name ) {
            return this.attributes[ attr_name ];
        },

        _binder: binder
    };
    // Subscribe to the PubSub
    binder.on( uid + ":input", function( evt, attr_name, new_val, initiator ) {
        if ( initiator !== user ) {
            user.set( attr_name, new_val );
        }
    });
    return user;
}
```
- html
```html
<input type="text" data-bind-1="name" />
<span data-bind-1="name"></span>
```
- js
```javascript
var DBind = new DBind( 1 );
DBind.set( "name", "黄奇" );
```
- 第二种方式
- html
```html
<input  ng-model type="text">
<p ng-bind></p>
```
- js
```javascript
var $scope = {name:'小红'}
// 1.当前打页面时，页面有小红值
var oIp = document.querySelector('[ng-model]')
oIp.value = $scope.name
// 2.改变文本框值时$scope.name也变
// 文本框有input事件
oIp.oninput = function(e){
    $scope.name =  e.target.value
    // 获取拥有ng-bind属性的元素
    // 设置它的innerHTML值
    document.querySelector('[ng-bind]').innerHTML = $scope.name
}
```
### 正则表达式
- 实现将数字千分制
```javascript
str.replace( /\B(?=(?:\d{3})+$)/g, ',' );
/*
* 逗号替换了 \B (非文字边界，匹配位置的左右两边都是 \w）
* (?=(?:\d{3})+$) 里的 (?= ) 部分表示匹配一个位置，这个位置之后的内容符合这个括号里的条件，也就是 (?:\d{3})+$
* (?:\d{3})+$ 表示一串长度可以被三整除的数字直至末尾
* 如果拿这个正则表达式匹配 123456789，匹配的步骤如下：
* "123,456798" （3 和 4 中间的位置是 \B，且之后的一串数字长度为三的倍数）;
* "123,456,789" （6 和 7 中间的位置满足）;
* /
```

## javaScript的this指向问题深度解析
> javaScript函数中的this指向并不是在函数定义的时候确定的,而是在调用的时候确定的(函数的调用方式决定了this的指向)
#### javaScript中的调用方式
- 直接调用
- 方法调用
- new调用
- 其他调用方式(bind(),箭头函数)
#### 直接调用
- 通过 ``函数名(...)`` 调用.函数内部的this指向全局对象,浏览器中全局对象是window,在nodeJs中全局对象是global;
- 一个例子
```javascript
//简单兼容浏览器和NodeJs的全局对象
const _global = typeof window === "undefined" ? global : window;
function test() {
    console.log(this === _global);//true
}
test();// 直接调用
```
-另一个直接调用的例子
```javascript
(function(_global) {
    // 通过 IIFE 限定作用域
    function test() {
        console.log(this === _global);// true
    }
    test();// 非全局作用域下的直接调用
})(typeof window === "undefined" ? global : window);
```
- 在这里,直接调用并不是指在全局作用域下进行调用,在任何作用域下,直接通过``函数名(...)``来对函数进行调用的方式,都称为直接调用.

#### bind()对直接调用的影响
- ``Function.prototype.bind()``的作用是将当前函数与指定的对象绑定,并返回一个新函数,这个新函数无论以什么样的方式调用,其``this``始终指向绑定的对象.
- 一个例子:
```javascript
const obj = {};
function test(){
    console.log(this === obj);
}

const testObj = test.bind(obj);
test(); //false
testObj(); //true
```

- 模拟bind对this产生的影响
```javascript
const obj = {};
function test() {
    console.log(this === obj);
}

//自定义函数模拟bind()对this的影响
function myBInd(func,target) {
    return function() {
        return func.apply(target,arguments);
    }
}

const testObj = myBind(test,obj);
test(); //false
testObj(); //true
```
- 从上面的示例中,首先,通过闭包,保持了``target``即绑定的对象;然后在调用函数的时候,对原函数使用了``apply``方法来指定函数的``this``.当然原生的``bind()``实现可能会不同,而且更高效. 

#### call和apply对this的影响
```javascript
const obj = {};
function test() {
    console.log(this === obj);
}
//绑定到一个新对象,而不是obj
const testObj = test.bind({});
test.apply(obj);//true
//期望this是obj,即输出true
//但是因为testObj绑定了不是obj的对象,所以会输出false
testObj.apply(obj); //false
```

#### 方法调用
- 方法调用是指通过对象来调用其方法函数，它是 ``对象.方法函数(...)`` 这样的调用形式。这种情况下，函数中的 ``this`` 指向调用该方法的对象。但是，同样需要注意 ``bind()`` 的影响。
```javascript
const obj = {
    // 第一种方式，定义对象的时候定义其方法
    test() {
        console.log(this === obj);
    }
};

// 第二种方式，对象定义好之后为其附加一个方法(函数表达式)
obj.test2 = function() {
    console.log(this === obj);
};

// 第三种方式和第二种方式原理相同
// 是对象定义好之后为其附加一个方法(函数定义)
function t() {
    console.log(this === obj);
}
obj.test3 = t;

// 这也是为对象附加一个方法函数
// 但是这个函数绑定了一个不是 obj 的其它对象
obj.test4 = (function() {
    console.log(this === obj);
}).bind({});

obj.test();     // true
obj.test2();    // true
obj.test3();    // true

// 受 bind() 影响，test4 中的 this 指向不是 obj
obj.test4();    // false
```
- 这里需要注意的是，后三种方式都是预定定义函数，再将其附加给 ``obj`` 对象作为其方法。再次强调，函数内部的 ``this`` 指向与定义无关，受调用方式的影响。
#### 方法中this指向全局对象的情况
- 注意这里说的是**方法**中而不是**方法调用**中。方法中的 ``this`` 指向全局对象，如果不是因为 ``bind()``，那就一定是因为不是用的方法调用方式
- 一个例子
```javascript
const obj = {
    test() {
        console.log(this === obj);
    }
};

const t = obj.test;
t();    // false
```
- ``t`` 就是 ``obj`` 的 ``test`` 方法，但是 ``t()`` 调用时，其中的 ``this`` 指向了全局。

- 之所以要特别提出这种情况，主要是因为常常将一个对象方法作为回调传递给某个函数之后，却发现运行结果与预期不符——因为忽略了调用方式对 ``this`` 的影响。比如下面的例子是在页面中对某些事情进行封装之后特别容易遇到的问题：
```javascript
class Handlers {
    // 这里 $button 假设是一个指向某个按钮的 jQuery 对象
    constructor(data, $button) {
        this.data = data;
        $button.on("click", this.onButtonClick);
    }

    onButtonClick(e) {
        console.log(this.data);
    }
}

const handlers = new Handlers("string data", $("#someButton"));
// 对 #someButton 进行点击操作之后
// 输出 undefined
// 但预期是输出 string data
```
- 很显然 ``this.onButtonClick`` 作为一个参数传入 ``on()`` 之后，事件触发时，是对这个函数进行的直接调用，而不是方法调用，所以其中的 ``this`` 会指向全局对象。要解决这个问题有很多种方法
```javascript
// 这是在 es5 中的解决办法之一
var _this = this;
$button.on("click", function() {
    _this.onButtonClick();
});

// 也可以通过 bind() 来解决
$button.on("click", this.onButtonClick.bind(this));

// es6 中可以通过箭头函数来处理，在 jQuery 中慎用
$button.on("click", e => this.onButtonClick(e));
```
- 不过请注意，将箭头函数用作 ``jQuery`` 的回调时造成要小心函数内对 ``this`` 的使用。``jQuery`` 大多数回调函数(非箭头函数)中的 ``this`` 都是表示调用目标，所以可以写 ``$(this).text()`` 这样的语句，但 ``jQuery`` 无法改变箭头函数的 ``this`` 指向，同样的语句语义完全不同。

# javascript的学习
## 进入javascript的第一步
- 像程序员一样思考
- 案例 [猜数字大小](../src/number-guessing-game-start.html)
    > **需求**:我想让你创建一个可以猜数字的游戏，它会在1~100以内随机选择一个数, 然后让玩家挑战在10轮以内猜出这个数字，每一轮都要告诉玩家正确或者错误， 如果出错了，则告诉他数字是低了还是高了，并且还要告诉玩家之前猜的数字是什么。 一旦玩家猜测正确，或者他们用完了回合，游戏将结束。 游戏结束后，可以让玩家选择再次开始。

    > 程序员的思路:

    - 1.生成1到100之间的随机数。
    - 2.记录球员所在的转弯数。在1开始。
    - 3.为玩家提供一种猜测数字的方法。 
    - 4.一旦提交了猜测，首先将它记录在某处，以便用户可以看到他们先前的猜测。
    - 5.接下来，检查它是否是正确的数字。
    - 6.如果是正确的：
        > 1.显示祝贺消息。
        
        > 2.阻止玩家输入更多的猜测（这会使游戏混乱）。

        > 3.显示控制允许玩家重新开始游戏。

    - 7.如果它错了，并且玩家已经左转：
        > 1.告诉玩家他们错了。

        > 2.允许他们输入另一个猜测。

        > 3.将圈数增加1。

    - 8.如果它是错误的，并且玩家没有左转：
        > 1.告诉玩家它是游戏结束。
        > 2.阻止玩家输入更多的猜测（这会使游戏混乱）。
        > 3.显示控制允许玩家重新开始游戏。
        
    - 9.一旦游戏重新启动，请确保游戏逻辑和用户界面完全重置，然后返回步骤1。

## 出错的地方
### 错误类型
- 1.语法错误:通过一些错误消息的提示,开发者工具解决问题
- 2.逻辑错误:没有错误指向的错误源
- [js常见错误参考](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Errors)
## 变量
- 用于存放数值的容器;独特之处在于它存放的数值是可以改变的;变量是用来存储数值的,变量不是数值本身，它们仅仅是一个用于存储数值的容器。
```html
<button>Press me</button>
```
```javascript
var button = document.querySelector('button');

button.onclick = function() {
  var name = prompt('What is your name?');
  alert('Hello ' + name + ', nice to see you!');
}
```
- 变量的类型
    - 数字类型
    - 字符串类型
    - 布尔值类型
    - 数组类型
    - 对象类型 var dog = { name : 'Spot', breed : 'Dalmatian' };

## 数字与运算符
- 数字类型
    - 整数
    - 浮点数
    - 双数
    - 二进制
    - 八进制
    - 十进制
    - 十六进制
- 算术运算符
    - 加 +
    - 减 -
    - 乘 *
    - 除 /
    - 模 %
- 算数优先级
> 在计算和的结果（在编程中称为表达式）时，某些运算符将在其他运算符之前应用。JavaScript中的运算符优先级与学习中的数学类中的相同 - 乘法和除法总是先进行，然后加法和减法（总是从左到右计算）。 
- 递增与递减
    - i++ ++i
    - i-- --i
- 分配符
    - += (x=3;x += 4 ==> x = x + 4)
    - -= (x=3;x -= 4 ==> x = x - 4)
    - *= (x=3;x *= 4 ==> x = x * 4)
    - /= (x=3;x /= 4 ==> x = x / 4) 
- 比较运算符
    - ===
    - ==
    - !==
    - !=    
